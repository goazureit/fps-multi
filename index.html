<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer FPS - Three.js</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial; }
        #container { position: relative; width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; z-index: 100; }
        #crosshair { 
            position: absolute; top: 50%; left: 50%; 
            width: 20px; height: 20px; 
            transform: translate(-50%, -50%);
            pointer-events: none; z-index: 100;
            border: 2px solid white; border-radius: 50%;
        }
        #health-bar { 
            position: absolute; bottom: 10px; left: 10px; 
            width: 200px; height: 20px; background: #222; 
            border: 2px solid white; z-index: 100; 
        }
        #health-fill { 
            height: 100%; background: #ff4444; transition: width 0.2s; 
        }
        #game-over { 
            display: none; position: absolute; top: 0; left: 0; 
            width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.8); 
            color: white; text-align: center; font-size: 48px; z-index: 200; 
            flex-direction: column; justify-content: center; align-items: center; 
        }
        #game-over button { 
            font-size: 24px; padding: 10px 20px; margin-top: 20px; cursor: pointer; 
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="container">
        <div id="ui">
            <div>WASD/Move | Mouse/Touch: Look | SPACE: Jump | Click/Tap: Shoot</div>
            <div>Players Online: <span id="playerCount">1</span></div>
        </div>
        <div id="crosshair"></div>
        <div id="health-bar"><div id="health-fill" style="width: 100%"></div></div>
        <div id="game-over">
            <div>Game Over</div>
            <button onclick="location.reload()">Respawn</button>
        </div>
    </div>

    <!-- Three.js + Controls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    
    <!-- Socket.io for multiplayer -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

    <script>
        class FPSGame {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.clock = new THREE.Clock();
                
                // Game state
                this.players = {};
                this.myId = null;
                this.keys = {};
                this.velocity = new THREE.Vector3();
                this.direction = new THREE.Vector3();
                this.isMobile = /Android|iPhone/i.test(navigator.userAgent);
                this.health = 100;
                this.canShoot = true;
                this.raycaster = new THREE.Raycaster();
                this.isGrounded = true;
                
                this.init();
                this.setupControls();
                this.setupMultiplayer();
                this.animate();
            }

            init() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x87CEEB);
                document.getElementById('container').appendChild(this.renderer.domElement);

                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 50, 50);
                this.scene.add(directionalLight);

                const groundGeo = new THREE.PlaneGeometry(100, 100);
                const groundMat = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
                const ground = new THREE.Mesh(groundGeo, groundMat);
                ground.rotation.x = -Math.PI / 2;
                this.scene.add(ground);

                this.camera.position.set(0, 1.8, 0);
                window.addEventListener('resize', () => this.onWindowResize());
            }

            setupControls() {
                this.renderer.domElement.addEventListener('click', () => {
                    this.renderer.domElement.requestPointerLock();
                    if (this.canShoot) this.shoot();
                });

                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if (e.code === 'Space') e.preventDefault();
                });
                document.addEventListener('keyup', (e) => this.keys[e.code] = false);

                let mouseX = 0, mouseY = 0;
                let touchStartX = 0, touchStartY = 0;

                if (!this.isMobile) {
                    document.addEventListener('mousemove', (e) => {
                        if (document.pointerLockElement) {
                            mouseX -= e.movementX * 0.002;
                            mouseY -= e.movementY * 0.002;
                            mouseY = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseY));
                            this.camera.rotation.set(mouseY, mouseX, 0);
                        }
                    });
                } else {
                    this.renderer.domElement.addEventListener('touchstart', (e) => {
                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                    });
                    this.renderer.domElement.addEventListener('touchmove', (e) => {
                        e.preventDefault();
                        const deltaX = e.touches[0].clientX - touchStartX;
                        const deltaY = e.touches[0].clientY - touchStartY;
                        mouseX -= deltaX * 0.005;
                        mouseY -= deltaY * 0.005;
                        mouseY = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseY));
                        this.camera.rotation.set(mouseY, mouseX, 0);
                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                    });
                    this.renderer.domElement.addEventListener('touchend', () => {
                        if (this.canShoot) this.shoot();
                    });
                }
            }

            setupMultiplayer() {
                console.log('Connecting to server: https://fps-multi.onrender.com');
                this.socket = io('https://fps-multi.onrender.com', { transports: ['websocket'] });
                
                this.socket.on('connect', () => {
                    this.myId = this.socket.id;
                    console.log('Connected:', this.myId);
                    this.addPlayer(this.myId, { x: 0, y: 1.8, z: 0 });
                });

                this.socket.on('connect_error', (error) => {
                    console.error('Connection error:', error.message);
                });

                this.socket.on('playerJoined', (data) => {
                    console.log('Player joined:', data.id, data.position);
                    if (data.id !== this.myId) {
                        this.addPlayer(data.id, data.position);
                    }
                });

                this.socket.on('playerMoved', (data) => {
                    console.log('Player moved:', data.id, data.position);
                    if (data.id !== this.myId) {
                        this.updatePlayer(data.id, data.position);
                    }
                });

                this.socket.on('playerLeft', (id) => {
                    console.log('Player left:', id);
                    this.removePlayer(id);
                });

                this.socket.on('hit', (data) => {
                    if (data.targetId === this.myId) {
                        this.health = Math.max(0, this.health - data.damage);
                        document.getElementById('health-fill').style.width = `${this.health}%`;
                        if (this.health <= 0) {
                            this.gameOver();
                        }
                    } else {
                        // Update other player's health
                        if (this.players[data.targetId]) {
                            this.players[data.targetId].health = Math.max(0, this.players[data.targetId].health - data.damage);
                            this.updateHealthBar(data.targetId);
                        }
                    }
                });

                setInterval(() => {
                    if (this.myId) {
                        this.socket.emit('move', {
                            id: this.myId,
                            position: { x: this.camera.position.x, y: this.camera.position.y, z: this.camera.position.z }
                        });
                    }
                }, 50);
            }

            createHealthBar() {
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 32;
                const context = canvas.getContext('2d');
                return { canvas, context };
            }

            updateHealthBar(id) {
                const player = this.players[id];
                if (!player || !player.healthBar) return;

                const { context } = player.healthBar;
                const healthPercent = player.health / 100;
                const color = healthPercent <= 0.25 ? `rgb(${255 * (1 - healthPercent / 0.25)}, ${255 * healthPercent / 0.25}, 0)` : `rgb(0, 255, 0)`;

                context.clearRect(0, 0, 128, 32);
                context.fillStyle = '#222';
                context.fillRect(0, 0, 128, 32);
                context.fillStyle = color;
                context.fillRect(2, 2, 124 * healthPercent, 28);

                player.healthBar.texture.needsUpdate = true;
            }

            shoot() {
                if (!this.canShoot) return;
                this.canShoot = false;
                setTimeout(() => this.canShoot = true, 500);

                const flashGeo = new THREE.SphereGeometry(0.1, 8, 8);
                const flashMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const flash = new THREE.Mesh(flashGeo, flashMat);
                flash.position.copy(this.camera.position);
                flash.position.add(this.camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(0.5));
                this.scene.add(flash);
                setTimeout(() => this.scene.remove(flash), 100);

                this.raycaster.set(this.camera.position, this.camera.getWorldDirection(new THREE.Vector3()));
                const intersects = this.raycaster.intersectObjects(
                    Object.values(this.players).map(p => p.mesh).filter(m => m !== undefined),
                    false
                );

                if (intersects.length > 0) {
                    const hitPlayer = Object.entries(this.players).find(
                        ([id, player]) => player.mesh === intersects[0].object
                    );
                    if (hitPlayer) {
                        const [targetId] = hitPlayer;
                        this.socket.emit('hit', { targetId, damage: 20 });

                        const hitGeo = new THREE.SphereGeometry(0.2, 8, 8);
                        const hitMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                        const hitEffect = new THREE.Mesh(hitGeo, hitMat);
                        hitEffect.position.copy(intersects[0].point);
                        this.scene.add(hitEffect);
                        setTimeout(() => this.scene.remove(hitEffect), 100);
                    }
                }
            }

            gameOver() {
                document.getElementById('game-over').style.display = 'flex';
                this.socket.disconnect();
                this.canShoot = false;
                this.keys = {};
            }

            respawn() {
                this.health = 100;
                document.getElementById('health-fill').style.width = '100%';
                this.camera.position.set(0, 1.8, 0);
                this.velocity.set(0, 0, 0);
                this.isGrounded = true;
            }

            addPlayer(id, position) {
                console.log('Adding player:', id, 'at position:', position);
                const geometry = new THREE.BoxGeometry(1, 1.8, 1);
                const material = new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(position.x + Math.random() * 2 - 1, position.y, position.z + Math.random() * 2 - 1);
                console.log('Mesh created for', id, 'at', mesh.position);
                this.scene.add(mesh);
                console.log('Mesh added to scene for', id);

                // Add health bar
                const { canvas, context } = this.createHealthBar();
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const healthBar = new THREE.Sprite(spriteMaterial);
                healthBar.position.set(0, 2.8, 0); // Above player (1.8 + 1)
                healthBar.scale.set(1, 0.25, 1);
                mesh.add(healthBar); // Attach to player mesh

                this.players[id] = { mesh, position: new THREE.Vector3(position.x, position.y, position.z), health: 100, healthBar: { canvas, context, texture } };
                this.updateHealthBar(id);
                document.getElementById('playerCount').textContent = Object.keys(this.players).length;
                console.log('Added player:', id, 'Total players:', Object.keys(this.players).length);
            }

            updatePlayer(id, position) {
                if (this.players[id]) {
                    console.log('Updating position for', id, 'to', position);
                    this.players[id].mesh.position.set(position.x, position.y, position.z);
                    this.players[id].position.set(position.x, position.y, position.z);
                } else {
                    console.log('Player not found for update:', id);
                }
            }

            removePlayer(id) {
                if (this.players[id]) {
                    console.log('Removing player:', id);
                    this.scene.remove(this.players[id].mesh);
                    delete this.players[id];
                    document.getElementById('playerCount').textContent = Object.keys(this.players).length;
                }
            }

            updateMovement(delta) {
                this.velocity.set(0, this.velocity.y, 0);

                // Align movement with camera direction
                const forward = new THREE.Vector3();
                this.camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0));

                this.direction.set(0, 0, 0);
                if (this.keys['KeyW']) this.direction.add(forward);
                if (this.keys['KeyS']) this.direction.sub(forward);
                if (this.keys['KeyD']) this.direction.add(right);
                if (this.keys['KeyA']) this.direction.sub(right);
                this.direction.normalize();

                if (this.keys['KeyW'] || this.keys['KeyS'] || this.keys['KeyA'] || this.keys['KeyD']) {
                    const speed = 5;
                    this.velocity.x = this.direction.x * speed;
                    this.velocity.z = this.direction.z * speed;
                }

                // Jump only if grounded
                if (this.keys['Space'] && this.isGrounded) {
                    this.velocity.y = 8;
                    this.isGrounded = false;
                }

                // Apply gravity
                this.velocity.y -= 10 * delta;
                this.camera.position.add(this.velocity.clone().multiplyScalar(delta));

                // Floor collision
                if (this.camera.position.y <= 1.8) {
                    this.camera.position.y = 1.8;
                    this.velocity.y = 0;
                    this.isGrounded = true;
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const delta = this.clock.getDelta();
                this.updateMovement(delta);
                this.renderer.render(this.scene, this.camera);
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        window.addEventListener('load', () => {
            console.log('Game initializing...');
            new FPSGame();
        });
    </script>
</body>
</html>